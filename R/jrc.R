#' @name Session
#' @title Session class
#' 
#' @description Objects of this class handle all the incoming and outgoing messages for one active connection.
#' Please, avoid creating instances of this class manually. Each \code{Session} object is created, when
#' a websocket is opened, and serves as a wraper around it. Manually created object will not have
#' a websocket connection and thus are not functional.
#' 
#' All sessions are stored whithin an object of class \code{\link{App}} and cannot exist and function without it.
#' One can manipulate a session directly, using its methods that are described bellow, via methods of the corresponding 
#' App object, or using provided wrapper function (links to them can be found in the Methods section).
#' 
#' @section Fields:
#' \describe{
#'    \item{\code{id}}{
#'       Automatically generated ID for this session. ID is a random combination of 6 letters or numbers.
#'       Please, do not change value this field.
#'    }
#'    \item{\code{lastActive}}{
#'       Time of the last received message via the session's websocket. The time is generated by
#'       \code{\link[base]{Sys.time}} function.
#'    }
#'    \item{\code{startTime}}{
#'       Time when this session has been started (generated by \code{\link[base]{Sys.time}} function).
#'    }
#'    \item{\code{maxN}}{
#'       Maximum number of messages that can be simultaneously stored for this session. Must be a single number.
#'       If \code{maxN = 0}, any message that requires authorization will be immediately discarded.
#'       If message storage is full, the oldest stored message will be removed, when a new one is stored. Default 
#'       value is \code{Inf}. 
#'    }
#'    \item{\code{maxSize}}{
#'       Maximum allowed size of the message storage in bytes. Must be a single number.
#'       If \code{maxSize = 0}, any message that requires authorization will be immediately discarded. If message stored is full,
#'       older messages will be removed, until either the allowed storage size is reached, or only one message remains. Default 
#'       value is \code{Inf}. 
#'    }
#' }
#' @section Methods:
#' \describe{
#'   \item{\code{getMessageIds()}}{
#'      Returns IDs of all currently stored messages. ID is combination of 6 random letters and numbers,
#'      which is generated, when the message is stored. See also \code{\link{getMessageIds}}.
#'   }
#'   \item{\code{authorize(messageId = NULL, show = FALSE)}}{ 
#'      Authorizes evaluation of the message. Check \code{\link{authorize}} for more information.
#'   }
#'   \item{\code{removeMessage(messageId)}}{
#'      Removes a stored message. This can also be done with \code{\link{authorize}} function (set
#'      \code{show = TRUE} and then select to ignore message). See also \code{\link{removeMessage}}.
#'   }
#'   \item{\code{sendCommand(command, wait = 0)}}{
#'      Sends a JavaScript command to be evaluated on the web page. Check 
#'      \code{\link{sendCommand}} for more information.
#'   }
#'   \item{\code{callFunction(name, arguments = NULL, assignTo = NULL, wait = 0, thisArg = NULL,  ...)}}{
#'      Calls an existing JavaScript
#'      function on the web page. Check \code{\link{callFunction}} for more information.
#'   }
#'   \item{\code{sendData(variableName, variable, wait = 0, keepAsVector = FALSE, rowwise = TRUE)}}{
#'      Sends data and assigns it to 
#'      a variable on the web page. Check \code{\link{sendData}} for more information.
#'   }
#'   \item{\code{sendHTML(html, wait = 0)}}{
#'      Sends HTML code that will be appended to the web page. Check \code{\link{sendHTML}} for 
#'      more information.
#'   }
#'   \item{\code{sessionVariables(vars = NULL, varName = NULL)}}{
#'      Sets or returns variables that are used (read or rewritten) only by this session. If both arguments are
#'      \code{NULL}, returns environment for this session. If \code{vars} is a named list, adds this variables to the
#'      session environment. If \code{varName} is a character, returns a variable with this name that can be accessed from
#'      the session. If no such variable exists, throws an error. One can add variables to the session evrironment and
#'      get a specified one back within the same function call.Check \code{\link{setSessionVariables}} for more information.
#'   }
#' }
#' Note, that the \code{Session} class has some other public methods that are not mentioned in this list. These methods are
#' intended to be used only by other functions of \code{jrc} package and therefore are not documented.
NULL

#' @importFrom stringi stri_rand_strings
#' @import stringr
#' @import R6
#' @importFrom jsonlite fromJSON
#' @importFrom utils object.size
#' @export
Session <- R6Class("Session", cloneable = FALSE, public = list(
  id = "",
  lastActive = NULL,
  startTime = NULL,
  maxN = Inf,
  maxSize = Inf,
  
  storeMessage = function(msg) {
    if(self$maxN == 0 | self$maxSize == 0) {
      message(str_c("Message can't be stored, sincse message storage is set to zero. ",
                    "Please, use 'limitStorage' function to change the limits."))
      return()
    }
    if(!is.vector(msg))
      stop("Unknown message format")

    if(msg[1] == "COM") {
      message(str_c("Command '", msg[2], "' is stored."))
    } else if(msg[1] == "DATA") {
      message(str_c("Assignment to the variable '", msg[2], "' is stored."))
    } else if(msg[1] == "FUN") {
      message(str_c("Call to the function '", msg[2], "' is stored."))
    } else {
      stop("Unknown message type. Must be one of 'COM', 'DATA' or 'FUN'")
    }
    
    messageId <- stri_rand_strings(1, 6)
    private$storage[[messageId]] <- list(msg = msg, size = object.size(msg), id = messageId)
    
    message(str_c("To authorize execution, please, type 'authorize(sessionId = \"", self$id, 
                  "\", messageId = \"", messageId, "\")'"))
    if(!private$waiting) {
      self$callFunction("jrc.notifyStorage", list(messageId))
    } else {
      private$waiting <- FALSE
    }
    self$lastActive <- Sys.time()
    
    private$cleanStorage()
  },
  execute = function(messageId = NULL, msg = NULL) {
    if(is.null(msg))
      if(is.null(messageId)) {
        stop("Either message of message ID must be provided.")
      } else {
        msg <- self$getMessage(messageId)
      }
    private$waiting <- FALSE

    if(is.null(msg))
      stop(str_c("There is no message with ID ", messageId))

    tryCatch({
      if(msg[1] == "COM") {
        eval(parse(text = msg[2]), envir = private$envir)
      } else if(msg[1] == "DATA") {
        # 1 = "DATA"
        # 2 - variable name
        # 3 - variable
        # 4 - boolean (sessionwise or outer envir)
        if(is.na(msg[[4]]))
          msg[[4]] <- exists(msg[[2]], inherits = FALSE, envir = private$envir)
        if(msg[[4]]) {
          assign(msg[[2]], msg[[3]], envir = private$envir)
        } else {
          assign(msg[[2]], msg[[3]], envir = parent.env(private$envir))
        }
      } else if(msg[1] == "FUN") {
        # 1 = "FUN"
        # 2 - function name
        # 3 - list of arguments
        # 4 - assignTo
        # 5 - package
        # 6 - boolean (sessionwise or outer envir)
        chain <- strsplit(msg[[2]], "[$]")[[1]]
        if(is.na(msg[[5]])) {
          f <- get(chain[1], envir = private$envir)
          chain <- chain[-1]
        } else {
          f <- getNamespace(msg[[5]])
        }
        for(el in chain) f <- f[[el]]
        
        if(is.na(msg[[5]]))
          environment(f) <- private$envir
        tmp <- do.call(f, msg[[3]], envir = private$envir)  
        
        if(!is.na(msg[[4]])){
          if(is.na(msg[[6]]))
            msg[[6]] <- exists(msg[[4]], inherits = FALSE, envir = private$envir)
          if(msg[[6]]) {
            assign(msg[[4]], tmp, envir = private$envir)
          } else {
            assign(msg[[4]], tmp, envir = parent.env(private$envir))
          }
        }
      }
    }, finally = {
      if(!is.null(messageId))
        self$removeMessage(messageId)
      self$lastActive <- Sys.time()
      }
    )
  },
  
  getMessage = function(messageId) {
    if(!is.character(messageId))
      stop("Message ID must be a string")
    if(length(messageId) > 1) {
      warning("An attepmt to supply several message IDs. Only the first one will be used")
      messageId <- messageId[1]
    }
    
    msgObj <- private$storage[[messageId]]
    if(!is.null(msgObj))
      msgObj <- msgObj$msg
    
    msgObj
  },
  removeMessage = function(messageId) {
    if(!is.character(messageId))
      stop("Message ID must be a string")
    if(length(messageId) > 1) {
      warning("An attepmt to supply several message IDs. Only the first one will be used")
      messageId <- messageId[1]
    }
  
    private$storage[[messageId]] <- NULL
    
    invisible(self)
  },
  
  getMessageIds = function() {
    sapply(private$storage, `[[`, "id")
  },
  
  sendCommand = function(command, wait = 0) {
    if(is.null(private$ws))
      stop("Websocket is already closed.")
    
    stopifnot(is.character(command))
      
    private$ws$send( toJSON(c("COM", command)) )
    
    if(wait > 0)
      private$wait(wait)
  },
  
  callFunction = function(name, arguments = NULL, assignTo = NULL, wait = 0, thisArg = NULL,  ...) {
    if(is.null(private$ws))
      stop("Websocket is already closed.")
    
    if(!is.character(name))
      stop("Function name must be a character")
    if(!is.null(assignTo) & !is.character(assignTo))
      stop("Variable name in 'assignTo' must be a character")
    
    if(!is.null(arguments)) {
      if(!is.list(arguments))
        stop("Arguments must be a list")
      names(arguments) <- NULL
      self$sendData("___args___", arguments, ...)
    }
    
    private$ws$send(toJSON(c("FUN", name, assignTo)))

    if(wait > 0)
      private$wait(wait)
  },
  
  sendData = function(variableName, variable, wait = 0, keepAsVector = FALSE, rowwise = TRUE) {
    if(is.null(private$ws))
      stop("Websocket is already closed.")
    
    stopifnot(is.character(variableName))
    if(length(variableName) > 1) {
      warning("An attempt to supply multiple variable names. Only the first one will be used.")
      variableName <- variableName[1]
    }
    
    if(rowwise) {
      dataframe <- "rows"
      matrix <- "rowmajor"
    } else  {
      dataframe <- "columns"
      matrix <- "columnmajor"
    }
    private$ws$send( toJSON(c("DATA", variableName, 
                                      toJSON(variable, digits = NA, dataframe = dataframe, matrix = matrix), 
                                      keepAsVector)))
    if(wait > 0)
      private$wait(wait)
  },
  
  sendHTML = function(html, wait = 0) {
    if(is.null(private$ws))
      stop("Websocket is already closed.")
    
    stopifnot(is.character(html))

    private$ws$send( toJSON(c("HTML", html)) )

    if(wait > 0)
      private$wait(wait)
  },
  
  authorize = function(messageId = NULL, show = FALSE) {
    
    if(is.null(messageId)) {
      if(length(private$storage) > 1)
        stop("More than one message is stored for this session. Please, specify message ID.")
      if(length(private$storage) == 0)
        stope("There are no stored messages for this session")
      messageId <- names(private$storage)
    }
    
    if(!is.logical(show))
      stop("show must be a logical variable")
  
    if(!show) {
      self$execute(messageId)
    } else {
      msg <- self$getMessage(messageId)
      if(is.null(msg))
        stop(str_c("There is no message with ID ", messageId))
  
      if(msg[1] == "COM") {
        text <- str_c("Command '", msg[2], "'.")
      } else if(msg[[1]] == "DATA") {
        text <- str_c("Assignment of varible '", msg[[2]], 
                      "'. New type is '", msg[[3]], "'. ",
                      "New size is ", msg[[3]], " bytes.")
      } else if(msg[[1]] == "FUN") {
        text <- str_c("Call of function '", msg[[2]], "'.")
        if(!is.na(msg[[4]]))
          text <- str_c(text, " Results will be assigned to variable '", msg[[4]], "'.")
      }
      text <- str_c(text, " To cancel enter '0'.")
      
      choice <- menu(c("Execute", "Ignore"), 
                     title = text)
      if(choice == 0) return()
      if(choice == 1) self$execute(messageId)
      
      self$removeMessage(messageId)
    }
    
    invisible(self)
  },
  
  sessionVaribles = function(vars = NULL, varName = NULL) {
    if(is.null(vars) && is.null(varName))
      return(private$envir)
    
    if(!is.null(vars)){
      if(!is.list(vars) || is.null(names(vars)))
        stop("Session variables must be a named list")
      list2env(vars, private$envir)   
    }
    if(!is.null(varName)){
      if(!is.character(varName))
        stop("Variable name must be a character")
      if(length(varName) > 1) {
        warning("Can't get several variables at once. Only the first variable name will be used")
        varName <- varName[1]
      }
      return(get(var, envir = private$envir))
    }
    ivisible(self)
  },
  
  setEnvironment = function(envir) {
    stopifnot(is.environment(envir))
    
    parent.env(private$envir) <- envir
    
    invisible(self)
  },
  
  close = function(message = NULL) {
    if(!is.null(message)) {
      if(!is.character(message))
        stop("Closing message must be a string.")
  
      self$sendCommand(str_c("alert('", mesage, "');"))
    }
    if(!is.null(private$ws))
      private$ws$close()
  },
  
  initialize = function(ws, envir = NULL) {
    self$id <- stri_rand_strings(1, 6)
    if(is.null(envir))
      envir <- new.env()
    stopifnot(is.environment(envir))
    
    private$envir <- envir
    
    self$lastActive <- Sys.time()
    self$startTime <- Sys.time()
    
    private$ws <- ws
    
    self$setSessionVariables(list(.id = self$id))      
  }
  
), private = list(
  ws = NULL,
  envir = NULL,
  storage = list(),
  waiting = FALSE,
  
  cleanStorage = function() {
    if(length(private$storage) > self$maxN){
      message(str_c("Too many messages! Message with id '", private$storage[[1]]$id, "' removed"))
      private$storage[1] <- NULL
    }
    
    while(sum(sapply(private$storage, `[[`, "size")) > self$maxSize & 
          length(private$storage) > 1){
      message(str_c("Messages size is too big! Message with id '", private$storage[[1]]$id, "' removed"))
      private$storage[1] <- NULL
    }
  },
  
  wait = function(time) {
    private$waiting <- TRUE
  
    for( i in 1:(time/0.05) ) {
      service(100)
      if( !private$waiting ){
        break
      } 
      Sys.sleep( .05 )
    }
    
    if(private$waiting) 
      warning(str_c("Failed to receive response from the websocket. Session ID: ", self$id))
    
    private$waiting <- FALSE
  }
))

#' @name App
#' @title App class
#' 
#' @description Object of this class represents the entire jrc-based app. It stores all the active connections,
#' user-specific variables and all the global app settings. If you use exported wrapper functions, 
#' without specifying an app object, an instance of this class is stored in the package namespace.
#' You can always retrieve it with the \code{\link{getPage}} function. However, it is also possible
#' to run several apps simultaneously by creating new objects of this class and then managing them 
#' directly.
#' 
#' @section Methods:
#' \describe{
#'    \item{\code{getSession(sessionId = NULL)}}{
#'       Returns a session with a given ID or \code{NULL} if session with this ID doesn't exist. If \code{sessionId = NULL}
#'       and there is only one active session, returns it. See also \code{\link{getSession}}.
#'    }
#'    \item{\code{closeSession(session = NULL, inactive = NULL, old = NULL)}}{
#'       Closes websocket connection of the session and removes all the related data from the app. For more information on 
#'       the arguments, please, check \code{\link{closeSession}}
#'    }
#'    \item{\code{getSessionIds()}}{
#'        Returns IDs of all currently active sessions. See also \code{\link{getSessionIds}}.
#'    }
#'    \item{\code{startServer(port = NULL)}}{
#'        Starts a local server that listens to a given port. If \code{port = NULL}, picks up a random available port.
#'        See also \code{\link{openPage}}.
#'    }
#'    \item{\code{stopServer()}}{
#'        Closes all active sessions and stops a running server. See also \code{\link{closePage}}.
#'    }
#'    \item{\code{openPage(useViewer = TRUE, browser = NULL)}}{
#'       Opens a new web page either in browser, or in R Studio viewer. If \code{useViewer = FALSE}, but browser is not selected,
#'       a default installed browser is used. If browser is specified, \code{useViewer} is ignored. This method returns
#'       a new Session object, which should correspond to the page that has been just opened. However, if someone would start
#'       a new connection at the moment when this function is used, it may return a wrong session. See also \code{\link{openPage}}.
#'    }
#'    \item{\code{setEnvironment(envir)}}{
#'       Specifies an environment in which all the messages from the web pages will be evaluated. For more information,
#'       please, check \code{\link{setEnvironment}}.
#'    }
#'    \item{\code{allowFunctions(funs = NULL)}}{
#'       Adds function names to a list of allowed functions. These functions can be called from the web page without authorization
#'       from the R side. If \code{funs = NULL}, then returns a list of all currently allowed functions. For more information,
#'       please, check \code{\link{allowFunctions}}.
#'    }
#'    \item{\code{allowVariables(vars)}}{
#'       Adds variable names to  the list of allowed variables. These variables can be rewritten from the web page without 
#'       authorization from the R side. If \code{vars = NULL}, then returns a vector of all currently allowed variable names.
#'       For more information, please, check \code{\link{allowVariables}}.
#'    }
#'    \item{\code{startPage(path = NULL)}}{
#'       Sets path to the starting web page of the app. Path can be full or relative to the app's root directory. If 
#'       \code{path = NULL}, returns current path to the starting page.
#'    }
#'    \item{\code{rootDirectory(path = NULL)}}{
#'       Sets path to the root directory for the server. Any file, requested by the server, will be looked for in this directory.
#'       Can be a full path or a path relative to the current working directory. If \code{path = NULL}, returns path to the
#'       current root directory.
#'    }
#'    \item{\code{numberOfConnections(maxCon = NULL)}}{
#'       Sets maximum number of connections to be active simultaneously. If \code{maxCon = NULL}, returns current number of 
#'       allowed connections. Default value is \code{Inf}.
#'    }
#'    \item{\code{new(rootDirectory = NULL, startPage = NULL, onStart = NULL, 
#'    connectionNumber = Inf, allowedFunctions = c(), allowedVariables = c(), sessionVars = NULL)}}{
#'       Creates a new instance of class App. Check \code{\link{openPage}} documentaion for information about
#'       arguments.
#'    }
#' }
#' 
NULL

#' @import mime
#' @export
App <- R6Class("App", cloneable = FALSE, public = list(
  addSession = function(session) {
    stopifnot("Session" %in% class(session))
    if(length(private$sessions) >= private$maxCon) {
      session$close("Maximum number of active connections has been reached.")
      stop("Maximum number of connections has been reached. Please, close some of 
           the existing sessions, before adding a new one.")
    }
    oldSession <- self$getSession(session$id)
    if(!is.null(oldSession)) {
      warning(str_c("Session with id ", session$id, " already exists. Existing session will be closed."))
      self$closeSession(oldSession)
    }
    private$sessions[[session$id]] <- session
  },
  
  getSession = function(sessionId = NULL) {
    if(is.null(sessionId))
      if(length(private$sessions) <= 1) {
        return(private$sessions[[1]])
      } else {
        stop("There are more than one active session. Please, specify session ID.")
      }
    if(!is.character(sessionId))
      stop("Session ID must be a string")
    
    private$sessions[[sessionId]]
  },
  
  closeSession = function(session = NULL, inactive = NULL, old = NULL) {
    if(!is.null(session)) {
      if(is.character(session))
        session <- self$getSession(session)
      if(is.null(session))
        stop("There is no session with this ID")
      
      stopifnot("Session" %in% class(session))
      session$close()
      private$sessions[[session$id]] <- NULL
    }
    sessionIds <- c()
    if(!is.null(inactive)) {
      lastActive <- sapply(private$sessions, `[[`, "lastActive")
      rem <- (lastActive < Sys.time() - inactive)
      sessionIds <- names(lastActive)[rem]
    }
    if(!is.null(old)) {
      startTime <- sapply(private$sessions, `[[`, "startTime")
      rem <- (startTime < Sys.time() - old)
      sessionIds <- unique(c(sessionIds, names(startTime)[rem]))
    }
    
    for(id in sessionIds) {
      session <- self$getSession(id)
      session$close()
      private$sessions[[id]] <- NULL
    }
    
    invisible(self)
  },
  
  getSessionIds = function() {
    names(private$sessions)
  },
  
  stopServer = function() {
    lapply(private$sessions, self$closeSession)
    
    if(!is.null(private$serverHandle)) {
      if(compareVersion(as.character(packageVersion("httpuv")), "1.3.5") > 0) {
        stopServer(private$serverHandle)
      } else {
        stopDaemonizedServer(private$serverHandle)
      }
      message("Server has been stopped.")      
    }
    
    invisible(self)
  },
  
  startServer = function(port = NULL) {

    if(is.null(port)) {
      if(compareVersion(as.character(packageVersion("httpuv")), "1.5.4") >= 0){
        port <- randomPort(n = 50)
      } else {
        #if there is no randomPort function in the httpuv package
        #in later versions of jrc this will be removed and httpuv >= 1.5.2 will be required
        #code adopted from httpuv::randomPort
        for (port in sample(seq(1024L, 49151L), 50)) {
          s <- NULL
          
          # Check if port is open
          tryCatch(
            s <- startServer("0.0.0.0", port, list(), quiet = TRUE),
            error = function(e) { }
          )
          if (!is.null(s)) {
            s$stop()
            break
          }
        }
      }
    }
    port <- as.integer(port)
    if(is.na(port))
      stop("Port number must be an integer number.")
    private$port <- port
    
    if(!(compareVersion(as.character(packageVersion("httpuv")), "1.3.5") > 0)) {
      private$serverHandle <- startDaemonizedServer( "0.0.0.0", private$port, private$getApp() )
    } else {
      private$serverHandle <- startServer( "0.0.0.0", private$port, private$getApp() )
    }
    
    invisible(self)
  },
  
  openPage = function(useViewer = TRUE, browser = NULL) {
    if(!is.null(browser))
      useViewer <- FALSE
    
    if(is.null(private$serverHandle))
      stop("No server is running. Please, start a server before opening a page.")
    if( useViewer & !is.null( getOption("viewer") ) )
      getOption("viewer")( str_c("http://localhost:", private$port, "/", private$startP) )
    else{
      if(is.null(browser))
        browser = getOption("browser")
      browseURL( str_c("http://localhost:", private$port, "/", private$startP), browser = browser )
    }
    
    
    # Wait up to 5 seconds for the a websocket connection
    # incoming from the client
    private$waiting <- TRUE
    for( i in 1:(5/0.05) ) {
      service(100)
      if( !private$waiting ){
       break
      } 
      Sys.sleep( .05 )
    }
    if( private$waiting ) {
      self$stopServer()
      stop( "Timeout waiting for websocket." )
    }
    
    invisible(private$sessions[[length(private$sessions)]])
  },
  
  setEnvironment = function(envir, sessionId = NULL) {
    stopifnot(is.environment(envir))
    private$envir <- envir
    
    if(is.null(sessionId))
      sessionId <- names(private$sessions)
    
    if(!is.null(sessionId)) {
      stopifnot(is.vector(sessionId))
      for(id in sessionId) 
        self$getSession(id)$setEnvironment(envir)
    }
    invisible(self)
  },
  
  allowFunctions = function(funs = NULL) {
    if(is.null(funs)) return(private$allowedFuns)
    if(!is.vector(funs) | !is.character(funs))
      stop("'funs' must be a vector of function names")
    
    private$allowedFuns <- unique(c(private$allowedFuns, funs))
    invisible(self)
  },
  
  allowVariables = function(vars = NULL) {
    if(is.null(vars)) return(private$allowedVars)
    if(!is.vector(vars) | !is.character(vars))
      stop("'funs' must be a vector of function names")
    
    private$allowedVars <- unique(c(private$allowedVars, vars))
    invisible(self)
    
  },
  
  rootDirectory = function(path = NULL) {
    if(is.null(path)) return(private$rootDir)
    stopifnot(is.character(path))
    
    if(!dir.exists(path))
      stop(str_c("There is no such directory: '", path, "'"))
    
    private$rootDir <- normalizePath(path)
    
    invisible(self)
  },
  
  startPage = function(path = NULL) {
    if(is.null(path)) {
      if(is.null(private$startPagePath)){
        return(path)
      } else {
        return(str_c(private$startPagePath, private$startP))
      }
    }
    stopifnot(is.character(path))
   
    if(file.exists(file.path(private$rootDir, page))){
      private$startP <- page
    } else {
      if(!file.exists(page))
        stop(str_c("There is no such file: '", page, "'"))
      page <- normalizePath(page)
      if(grepl(page, private$rootDir, fixed = T)) {
        private$start <- str_remove(page, str_c(private$rootDir, "/"))
      } else {
        private$startP <- "index.html"
        private$startPagePath <- page
      }
    }
    
  },
  
  numberOfConnections = function(maxCon = NULL) {
    if(is.null(maxCon))
      return(private$maxCon)
    
    stopifnot(is.numeric(maxCon))
    
    private$maxCon <- maxCon
    
    invisible(self)
  },
  
  sessionVariables = function(vars = NULL) {
    if(is.null(vars))
      return(private$sessionVariables)
    
    vars <- as.list(vars)
    if(!is.list(vars))
      stop("Variables must be a list")
    
    if(is.null(names(vars)))
      stop("List of variables must be named")
    
    for(n in names(vars))
      private$sessionVaribles[[n]] <- vars[[n]]
    
    invisible(self)
  },
  
  initialize = function(rootDirectory = NULL, startPage = NULL, onStart = NULL, 
                        connectionNumber = Inf, allowedFunctions = c(), 
                        allowedVariables = c(), sessionVars = NULL) {
    if(is.null(rootDirectory)) 
      rootDirectory <- system.file("http_root", package = "jrc")
    self$setRootDirectory(rootDirectory)
    
    if(is.null(startPage))
      startPage <- system.file("http_root/index.html", package = "jrc")
    self$setStartPage(startPage)
    
    private$envir <- parent.frame(n = 2)
    
    if(is.null(onStart)) {
      onStart <- function(session) {}
    }
    stopifnot(is.function(onStart))
    private$onStart <- onStart
    
    
    self$allowFunctions(allowedFunctions)
    self$allowVariables(allowedVariables)
    self$setSessionVariables(sessionVars)
    self$limitConnectionNumbers(connectionNumber)
    
    invisible(self)
  }
  
), private = list(
  sessions = list(),
  serverHandle = NULL,
  envir = NULL,
  allowedFuns = c(),
  allowedVars = c(),
  maxCon = Inf,
  port = NULL,
  waiting = FALSE,
  onStart = NULL,
  rootDir = "",
  startP = "",
  startPagePath = NULL,
  sessionVars = list(),
  
  getApp = function() {
    handle_http_request <- function( req ) {
      
      reqPage <- req$PATH_INFO
      if(grepl("^/http_root", reqPage)) {
        pack <- substring(strsplit(reqPage, "/")[[1]][2], 11)
        reqPage <- sub(str_c("_", pack), "", reqPage)
        reqPage <- system.file( reqPage, package = pack )
      } else {
        if(reqPage == "/index.html" & !is.null(private$startPagePath)) {
          reqPage <- private$startPagePath
        } else {
          reqPage <- str_c(private$rootDir, reqPage)
        }
      }
      
      if( !file.exists(reqPage) ) {
        reqPage <- str_remove(reqPage, private$rootDir)
        if(!file.exists(reqPage)) {
          warning(str_interp("File '${reqPage}' is not found"))
          return( list( 
            status = 404L,
            headers = list( "Content-Type" = "text/html" ),
            body = "404: Resource not found" ) )
        }
      }
      
      content_type <- mime::guess_type(reqPage)
      content <- readLines(reqPage, warn = F)
      
      if(content_type == "text/html") {
        jsfile <- str_c("<script src='http_root_jrc/jrc.js'></script>")
        stop <- F
        for(i in 1:length(content))
          if(str_detect(content[i], regex("<head", ignore_case = T))) {
            stop <- T
            content[i] <- str_replace(content[i], regex("(<head[^>]*>)", ignore_case = T), str_c("\\1", jsfile))
          }
        #the document has no <head> tag
        if(!stop) {
          jsfile <- str_c("<head>", jsfile, "</head>")
          for(i in 1:length(content))
            if(str_detect(content[i], regex("<html", ignore_case = T))) {
              stop <- T
              content[i] <- str_replace(content[i], regex("(<html[^>]*>)", ignore_case = T), str_c("\\1", jsfile))
            }
        }
        if(!stop)
          content <- c(jsfile, content)
      }
      
      list(
        status = 200L,
        headers = list( 'Content-Type' = content_type ),
        body = str_c( content, collapse="\n" )
      )
    }
    handle_websocket_open <- function( ws ) {
      session <- Session$new(ws, envir = new.env(parent = private$envir))
      session$sessionVariables(private$sessionVars)
      
      ws$onMessage( function( isBinary, msg ) {
        if( isBinary )
          stop( "Unexpected binary message received via WebSocket" )
        msg <- fromJSON(msg)
        if(!(msg[1] %in% c("COM", "FUN", "DATA")))
          stop(str_interp("Unknown message type: ${msg[1]}"))
        
        if(msg[1] == "COM") {
          session$storeMessage(msg) #vector of characters
        } 
        if(msg[1] == "DATA") {
          if(!is.character(msg[2]))
            stop("Invalid message structure. Variable name is not character.")
          
          msg <- as.list(msg)
          msg[[3]] <- fromJSON(msg[[3]])
          
          if(msg[[2]] %in% private$allowedVars) {
            session$execute(msg = msg)
          } else {
            session$storeMessage(msg)
          }
        }
        
        if(msg[1] == "FUN") {
          if(!is.character(msg[2]))
            stop("Invalid message structure. Function name is not character.")
          #make sure that function arguments is a list
          
          msg <- as.list(msg)
          if(!is.na(msg[[3]])) 
            msg[[3]] <- fromJSON(msg[[3]])
          if(is.vector(msg[[3]]))
            msg[[3]] <- as.list(msg[[3]])
          if(length(msg[[3]]) == 1 && is.na(msg[[3]]))
            msg[[3]] <- list()
          
          msg[[3]] <- as.list(msg[[3]])
          if(!is.list(msg[[3]]))
            stop("Invalid message structure. List of arguments is not a list.")
          #go through all arguments and turn to numeric
          
          if(msg[[2]] %in% private$allowedFuns & (is.na(msg[[4]]) | msg[[4]] %in% private$allowedVars)) {
            session$execute(msg = msg)
          } else {
            session$storeMessage(msg)
          }
        }
      } );
      
      ws$onClose(function() {
        if(!is.null(self$getSession(session$id)))
          self$closeSession(session$id)
      })      
      
      session$setSessionVariables(private$sessionVars)
      self$addSession(session)
    
      private$onStart(session)
      private$waiting <- FALSE
    }
    
    list(call = handle_http_request,
         onWSOpen = handle_websocket_open)
  }
))

pkg.env <- new.env()


#' Create a server
#' 
#' \code{openPage} starts a server and opens a new page with a websocket connection between it and the current
#' R session. After that messages can be exchanged between R session and the web page to generate content on the
#' web page and to trigger calculation in R as a response to user activity on the page.
#' 
#' \code{jrc} supports four types of messages:
#' \itemize{
#'    \item{Commands are pieces of R or JavaScript code that will be evaluated on the receiving side. Note, 
#'    that any command from the web page must be authorized in the R session for security reasons. A message 
#'    with information on how to do that is printed in the console each time a command is received. For more
#'    information, please, check \code{\link{sendCommand}}}
#'    \item{Data is any variable that is sent to a from the current R session. It must always come with a 
#'    name of variable to which it should be assigned on the receiving side. For more information, please,
#'    check \code{\link{sendData}}}
#'    \item{Function calls can be triggered on each side of the websocket connection. Alongside the function name,
#'    one can also send a list of arguments and name of a variable to which the returned value of the function will
#'    be assigned. For more information, please, check \code{\link{callFunction}}}
#'    \item{Unlike other types of messages, HTML code can be sent only from R session to the web page. This code will
#'    be added to the body of the page.}
#' }
#' 
#' \code{openPage} function is a wrapper around several methods of class \code{\link{App}}. First, it creates an
#' instance of this class. Then it starts a server that listens to a given port. And finally, it attempts
#' to open a new web page. It also stores a new app object in tha package namespace, which allows other
#' wrapper functions access it without being specified by the user.
#' 
#' @param useViewer If \code{TRUE}, the new web page will be opened in the RStudio Viewer. If \code{FALSE}
#' a default web browser will be used (if other is not specified with the \code{browser} argument.
#' @param rootDirectory A path to the root directory of the server. Any file, requested by the server
#' will be searched for in this directory. If \code{rootDirectory} is not 
#' defined, the \code{http_root} in the package directory will be used as a root directory.
#' @param startPage A path to the HTML file that should be used as a starting page of the app.
#' This can be an absolute path to a local file, or it can be relative to the \code{rootDirectory}
#' or to the current R working directory. If \code{startPage} is not defined, an empty page will be used.
#' The file must have \emph{.html} extension.
#' @param port Defines which TCP port the server will listen to. If not defined, random available port
#' will be used.
#' @param browser A browser in which to open a new web page.
#' If not defined, default browser will be used. For more information check \code{\link[utils]{browseURL}}.
#' Specifying a browser, will automatically set \code{useViewer} to \code{FALSE}.
#' @param allowedFunctions List of functions that can be called from the web page without any additional actions 
#' from the user. All other functions will require authorization in the current R session before they are executed. 
#' This should be a vector of function names. Check \code{\link{authorize}} and \code{\link{allowFunctions}}
#' for more information. 
#' @param allowedVariables List of variables that can be reassigned from the web page without any additional actions 
#' from the user. All other reassignments will require authorization in the current R session before they are executed. 
#' This should be a vector of variable names. Check \code{\link{authorize}} and \code{\link{allowVariables}}
#' for more information.
#' @param connectionNumber Maximum number of connections that is allowed to be active simultaneously.
#' @param sessionVars Named list of variables, that will be declared for each session, when a new connection is opened.
#' Any changes to these variables will affect only a certain session. Thus they can be used, for instance, to 
#' store a state of each session. For more information, please, check \code{\link{setSessionVariables}}.
#' @param onStart A callback function that will be executed when a new connection is opened. This function get a single 
#' variable, which is an object of class \code{\link{Session}}. General purpose of the function is to populate each 
#' new web page with some default content.
#' 
#' @seealso \code{\link{closePage}}, \code{\link{setEnvironment}}, \code{\link{limitStorage}}, \code{\link{allowVariables}},
#' \code{\link{allowFunctions}}, \code{\link{setSessionVariables}}.
#' 
#' @return Object of class \code{\link{App}}.
#' 
#' @export
#' @import httpuv
#' @importFrom utils browseURL
#' @importFrom utils compareVersion
#' @importFrom utils packageVersion
openPage <- function(useViewer = TRUE, rootDirectory = NULL, startPage = NULL, port = NULL, browser = NULL,
                     allowedFunctions = NULL, allowedVariables = NULL, connectionNumber = Inf, sessionVars = NULL,
                     onStart = NULL) {
  if(!is.null(pkg.env$app))
    closePage()
  
  app <- App$new(rootDirectory, startPage, onStart, connectionNumber, allowedFunctions, allowedVariables, sessionVars)
  app$setEnvironment(parent.frame())
  app$startServer(port)
  app$openPage(useViewer, browser)
  pkg.env$app <- app
  
  invisible(app)
}

sendMessage <- function(type, id, ...) {
  if(is.null(pkg.env$app))
    stop("There is no opened page. Please, use 'openPage()' function to create one.")
  
  if(is.null(id))
    id <- pkg.env$app$getSessionIds()$id
  for(i in id){
    session <- pkg.env$app$getSession(i)
    if(is.null(session)) {
      warning(str_c("There is no session with ID ", i))
    } else {
      tryCatch(session[[type]](...), 
               error = function(e) {
                 if(e$message == "Websocket is already closed.") {
                   pkg.env$app$closeSession(session)
                   stop(str_c("Websocket is already closed.", 
                              "Session ", session$id, " has been terminated."))
                 } else {
                   stop(e)
                 }
               })
    }
  }
  
}

#' Send a command to a web page
#' 
#' \code{sendCommand} sends JavaScript code to the server and executes it on the specified
#' opened page. Use JavaScript function \code{jrc.sendCommand} to send R code from the web page
#' and execute it in the current R session. All commands send to R from the server will be executed
#' only after authorization in the currently running R session.
#' @details Each opened page gets its own environment, where all the commands are evaluated. Thus, any changes
#' made with the usual assignment operator \code{<-} will be limited to the page-specific environment. The changes
#' are still saved, but can be accessed only with \code{\link{getSessionVariable}} function. To make changes outside
#' of the page-specific environment use \code{<<-} instead. In JavaScript \code{windows.varibleName = "SomeValue"}
#' should be used instead of \code{varibleName = "SomeValue"}, if you want the variable to be accessable outside the
#' currend \code{sendCommand} call.
#' 
#' This function is a wrapper around \code{sendCommand} method of class \code{\link{Session}}.
#' 
#' @param command A line (or several lines separated by \code{\\n}) of JavaScript code. This code
#' will be immediately executed on the opened page. No R-side syntax check is performed.
#' @param sessionId An ID of the session to which the command should be sent. If \code{NULL}, the command will
#' be sent to all currently active sessions.
#' @param wait If \code{wait > 0}, after sending the message, R will wait for a reply for a given number of seconds. 
#' For this time (or until the reply is received), execution of other commands will be halted. Any incoming message 
#' from the session will be considered as a reply.
#' 
#' @examples  
#' \donttest{k <- 0
#' openPage()
#' sendCommand(paste0("button = document.createElement('input');",
#'               "button.type = 'button';",
#'               "button.addEventListener('click', function() {jrc.sendCommand('k <<- k + 1')});", 
#'               "button.value = '+1';",
#'               "document.body.appendChild(button);", collapse = "\n"))
#' closePage()}
#' 
#' @seealso \code{\link{authorize}}, \code{\link{sendData}}, \code{\link{sendHTML}}, \code{\link{callFunction}},
#' \code{\link{openPage}}.
#' 
#' @export
#' @importFrom jsonlite toJSON
sendCommand <- function(command, sessionId = NULL, wait = 0) {
  sendMessage("sendCommand", sessionId, wait = wait, command = command)
}


#' Stop server
#' 
#' Stop the server and close all currently opened pages (if any). This function is a 
#' wrapper of \code{stopServer} method of class \code{\link{App}}.
#' 
#' @seealso \code{\link{openPage}}
#' 
#' @export
closePage <- function() {
  if(!is.null(pkg.env$app)) {
    pkg.env$app$stopServer()
    pkg.env$app <- NULL
  } else {
    message("There is no opened page.")
  }
}

#' Send data to a web page
#' 
#' Sends a variable to a web page, where it is assigned to the variable with a specified name. 
#' 
#' To send data back from the web page to the currend R session \code{jrc.sendData(variableName, variable, internal)} 
#' should be used. Its arguments are:
#' 
#' \describe{
#'    \item{\code{variableName}}{
#'       Name that the variable will have in the R session. If variable name hasn't been previously added to the list
#'       of allowed variables (see \code{\link{allowVariables}} or \code{allowedVariables} argument of the \code{\link{openPage}}
#'       fuction), attempt to assign it from a web page will require manual authorization in the R session.
#'    }
#'    \item{\code{variable}}{
#'       Variable to send.
#'    }
#'    \item{\code{internal} (optional)}{
#'       Whether this variable should be used only by the session that sent it. If \code{true}, variable will be stored
#'       in the session-specific environment and can be accessed from the outside with \code{\link{getSessionVariable}}
#'       function. If \code{false}, variable will be saved to the outer environment of the app (see \code{\link{setEnvironment}}).
#'       By default, uses \code{true} for variables that already exist in the session specific environment 
#'       (see \code{\link{setSessionVariables}} or \code{sessionVariables} argument of the \code{\link{openPage}} function.)
#'       and \code{false} otherwise.
#'    }
#' }
#' 
#' @param variableName Name that the variable will have on the web page.
#' @param variable Variable to send.
#' @param sessionId An ID of the session to which the data should be sent. If \code{NULL}, the data will
#' be sent to all currently active sessions.
#' @param wait If \code{wait > 0}, after sending the message, R will wait for a reply for a given number of seconds. 
#' For this time (or until the reply is received), execution of other commands will be halted. Any incoming message 
#' from the session will be considered as a reply.
#' @param keepAsVector If \code{TRUE}, variables with length 1 will be saved as arrays on the server, otherwise they 
#' will be converted to atomic types.
#' @param rowwise If \code{TRUE}, matrices and data.frames will be transformed into JavaScript Objects or Arrays
#' rowwise (e.g. a matrix will become an Array of its rows). 
#' 
#' @examples 
#' \donttest{openPage()
#' x <- 1:100
#' sendData("x", x)
#' sendCommand("console.log(x);")
#' sendCommand("jrc.sendData('x', x.filter(function(e) {return e % 2 == 0}))")
#' closePage()}
#' 
#' @seealso \code{\link{authorize}}, \code{\link{allowVariables}}, \code{\link{sendCommand}},
#' \code{\link{callFunction}}, \code{\link{sendHTML}}, \code{\link{openPage}}.
#'  
#' @export
#' @importFrom jsonlite toJSON
sendData <- function(variableName, variable, sessionId = NULL, wait = 0, keepAsVector = FALSE, rowwise = TRUE) {
  sendMessage("sendData", sessionId, wait = wait, variableName = variableName, variable = variable, keepAsVector = keepAsVector,
              rowwise = rowwise)
}

#' Set Environment
#' 
#' Defines an outer environment for the app. Outer environment is a parent for all session environments.
#' It is used to store variables that are common for all the sessions. The only way to make changes outside
#' the outer environment is to use the global assignment operator \code{<<-} if and only if changes are 
#' made to the variable that does not exist in the outer environment.
#' 
#' By default, an environment where app was initialized (via \code{\link{openPage}} function or with \code{App$new()} call)
#' is used.
#' 
#' @param envir Environment to be used as outer environment. 
#' 
#' @examples
#' \donttest{
#' openPage()
#' e <- new.env()
#' setEnvironment(e)
#' 
#' sendCommand("jrc.sendData('x', 10)", wait = 3)
#' print(e$x)
#' closePage()
#' }
#' 
#' @export
setEnvironment <- function(envir) {
  if(is.null(pkg.env$app))
    stop("There is no opened page. Please, use 'openPage()' function to create one.")
  
  pkg.env$app$setEnvironment(envir)
}

#' Send HTML to a web page
#' 
#' Sends a piece of HTML code to an opend web page and adds it at the end
#' or the \code{body} element.
#' 
#' @param html HTML code that will be added to the web page.
#' @param sessionId An ID of the session to which the HTML should be sent. If \code{NULL}, the HTML will
#' be sent to all currently active sessions.
#' @param wait If \code{wait > 0}, after sending the message, R will wait for a reply for a given number of seconds. 
#' For this time (or until the reply is received), execution of other commands will be halted. Any incoming message 
#' from the session will be considered as a reply.
#' 
#' @examples 
#' \donttest{
#' openPage(FALSE)
#' 
#' sendHTML("Test...")
#' sendHTML("This is <b>bold</b>")
#' sendHTML("<table><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr></table>")}
#' 
#' @seealso \code{\link{sendData}}, \code{\link{sendCommand}}, \code{\link{callFunction}},
#' \code{\link{openPage}}.
#' 
#' @export
sendHTML <- function(html = "", sessionId = NULL, wait = 0) {
  sendMessage("sendHTML", sessionId, wait = wait, html = html)
}

#' Trigger a function call
#' 
#' Calls a function on an opened web page given its name and arguments.
#' 
#' JavaScript counterpart is \code{jrc.callFunction(name, arguments, assignTo, package, internal)},
#' and its arguments are:
#' \describe{
#'    \item{\code{name}}{
#'       Name of the function to call. If function name hasn't been previously added to the list
#'       of allowed functions (see \code{\link{allowFunctions}} or \code{allowedFunctions} argument of the \code{\link{openPage}}
#'       fuction), attempt to assign it from a web page will require manual authorization in the R session.
#'    }
#'    \item{\code{arguments} (optional)}{
#'       arguments for the function. This should be an Array or an Object with argument names as keys.
#'    }
#'    \item{\code{assignTo} (optional)}{
#'       Name of the variable to which the returned value of the function will be assignedin the R session. 
#'       If variable name hasn't been previously added to the list
#'       of allowed variables (see \code{\link{allowVariables}} or \code{allowedVariables} argument of the \code{\link{openPage}}
#'       fuction), attempt to assign it from a web page will require manual authorization in the R session.
#'    }
#'    \item{\code{package} (optional)}{
#'       If the function should be imported from an installed package, name of this package.
#'    }
#'    \item{\code{internal} (optional)}{
#'       Whether assignment of the function returned value should happen internally or not. If \code{true}, result will be stored
#'       in the session-specific environment and can be accessed from the outside with \code{\link{getSessionVariable}}
#'       function. If \code{false}, result will be saved to the outer environment of the app (see \code{\link{setEnvironment}}).
#'       By default, uses \code{true} for variables that already exist in the session specific environment 
#'       (see \code{\link{setSessionVariables}} or \code{sessionVariables} argument of the \code{\link{openPage}} function.)
#'       and \code{false} otherwise.
#'    }
#' }
#' 
#' @param name Name of the function. If the function is a method of some object
#' its name must contain the full chain of calls (e.g. \code{myArray.sort} or 
#' \code{Math.rand}).
#' @param arguments List of arguments for the function. Note that in JavaScript 
#' arguments must be given in a fixed order, naming is not necessary and will 
#' be ignored.
#' @param assignTo Name of a variable to which will be assigned the returned value
#' of the called function.
#' @param sessionId An ID of the session to which the function call should be sent. If \code{NULL}, the function call will
#' be sent to all currently active sessions.
#' @param wait If \code{wait > 0}, after sending the message, R will wait for a reply for a given number of seconds. 
#' For this time (or until the reply is received), execution of other commands will be halted. Any incoming message 
#' from the session will be considered as a reply.
#' @param thisArg JavaScript functions (methods) can belong to some object, which 
#' is referred as \code{this} inside the function (e.g. in
#' \code{someObject.myFunction()} function \code{myFunction} is a method of \code{someObject}).
#' \code{thisArg} specified object that will be passed as \code{this} to the function. If \code{NULL}
#' then the function will be applied to the global object.
#' @param ... further arguments passed to \code{\link{sendData}} that is used to send
#' \code{arguments} to the web page.
#' 
#' @examples 
#' \donttest{
#' openPage()
#' callFunction("alert", list("Some alertText"))
#' callFunction("Math.random", assignTo = "randomNumber")
#' }
#' 
#' @seealso \code{\link{authorize}}, \code{\link{allowFunctions}}, \code{\link{allowVariables}},
#' \code{\link{setEnvironment}}.
#' 
#' @export
callFunction <- function(name, arguments = NULL, assignTo = NULL, wait = 0, sessionId = NULL, thisArg = NULL, ...) {
  sendMessage("callFunction", sessionId, wait = wait, name = name, arguments = arguments, assignTo = assignTo, thisArg = thisArg,
                ...)
}

#' Authorize further message processing
#' 
#' `jrc` library allows one to get a full control over the currently running R session from 
#' a web page. Therefore for security reasons one should manually authorize function calls,
#' variable assignments or expression evaluations. All the received messages that are not
#' processed automatically are given an ID and stored. This function executes a command
#' from a message with a given ID
#' 
#' Expressions has to be always authorized before evaluation. One can specify a list of
#' variables that can be reassigned automatically and functions that can be called without
#' authorization.
#' 
#' @param id ID of the message to be processed. In `jrc` library all stored messages are
#' give a random ID that consists of 6 letters or numbers. The ID is reported when the
#' message is stored. To get a list of IDs of all currently stored messages, set this argument
#' to \code{NULL}.
#' @param show If \code{TRUE} information of the message with a given ID will be show before executing
#' it with a choice to go on with execution, ignore the message (meaning it will be removed from memory) or
#' do nothing.
#' 
#' @return A vector of IDs of all currently stored messages.
#' 
#' @seealso \code{\link{allowFunctions}}, \code{\link{allowVariables}}, \code{\link{sendCommand}},
#' \code{\link{sendData}}, \code{\link{callFunction}}, \code{\link{limitStorage}}.
#' 
#' @export
#' @importFrom utils menu
authorize <- function(sessionId, messageId = NULL, show = FALSE) {
  if(is.null(pkg.env$app))
    stop("There is no opened page. Please, use 'openPage()' function to create one.")  
  
  session <- pkg.env$app$getSession(sessionId)
  if(is.null(session))
    stop(str_c("There is no session with ID ", sessionId))
  
  session$authorize(messageId, show)
}

#' Allow function calls without authorization
#' 
#' This function adds function names to the list of functions, which
#' can be called from the web page without manual confirmation in the R
#' session.
#' 
#' @param funs Vector of function names to be added to the list. If is \code{NULL},
#' returns names of all currently allowed functions.
#' 
#' @return Names of all currently allowed functions if \code{funs = NULL}.
#' 
#' @examples
#' allowFunctions(c("myFunction1", "print", "someObject$method"))
#' funs <- allowFunctions()
#' 
#' @seealso \code{\link{allowVariables}}, \code{\link{authorize}}, \code{\link{openPage}} (check argument
#' \code{allowedFunctions}), \code{\link{callFunction}}.
#' 
#' @export
allowFunctions <- function(funs = NULL) {
  if(is.null(pkg.env$app))
    stop("There is no opened page. Please, use 'openPage()' function to create one.")
  
  pkg.env$app$allowFunctions(funs)
}

#' Allow variable assignment without authorization
#' 
#' This function adds variable names to the list of variables, which
#' can be reassigned from the web page without manual confirmation in the R
#' session.
#' 
#' @param vars Vector of variable names to be added to the list. If is \code{NULL},
#' returns names of all currently allowed variables.
#' 
#' @examples
#' allowVariables(c("myVariable", "anotherOne"))
#' vars <- allowVariables()
#' 
#' @return Names of all currently allowed variables if \code{vars = NULL}.
#' 
#' @seealso \code{\link{allowFunctions}}, \code{\link{authorize}}, \code{\link{openPage}} (check argument
#' \code{allowedVariables}), \code{\link{sendData}}.
#' 
#' @export
allowVariables <- function(vars = NULL) {
  if(is.null(pkg.env$app))
    stop("There is no opened page. Please, use 'openPage()' function to create one.")  
  
  pkg.env$app$allowVariables(vars)
}

#' Change size of the message storage
#' 
#' This function allows to change number of total size of the messages
#' that are received via the websocket and are stored in the memory.
#' 
#' For security reasons, the control of the currently running R session is limited
#' to calling only some user specified functions and reassigning some user specified
#' variables. All other messages are stored in the memory and can be later processed
#' by calling \code{\link{authorize}} function. To prevent overuse of memory, one can 
#' limit the size of the storage by number of messages or by their total size estimated
#' by \code{\link[utils]{object.size}}. If the storage grows above the set limits, older
#' messages are removed. The last received message will not be removed even if its 
#' takes more memory than is allowed by this function.
#' 
#' @param n Number of messages that can be stored simultaneously.
#' @param size Maxim total size of all stored messages in bytes.
#' 
#' @return Current maximum size of the storage and maximum allowed number of stored messages.
#' 
#' @examples 
#' limitStorage(n = 10)
#' limitStorage(size = 10 * 1024^2)
#' lim <- limitStorage()
#' 
#' @seealso \code{\link{authorize}}, \code{\link{allowFunctions}}, \code{\link{allowVariables}}.
#' 
#' @export
limitStorage <- function(n = NULL, size = NULL) {
  limitStorage = function(n = NULL, size = NULL) {
    if(!is.null(n)) {
      if(!is.numeric(n))
        stop("Maximum number of stored messages 'n' must be numeric")
      if(n < 0)
        stop("Maximum number of stored messages 'n' must be non-negative")
      private$maxCon <- n
    }
    if(!is.null(size)) {
      if(!is.numeric(size))
        stop("Maximum size of stored messages 'size' must be numeric")
      if(size < 0)
        stop("Maximum size of stored messages 'size' must be non-negative")
      self$maxSize <- size
    }
    
    c(n = private$maxN, size = self$maxSize)
  }
  
    if(is.null(pkg.env$app))
    stop("There is no opened page. Please, use 'openPage()' function to create one.")  
  
  pkg.env$app$limitStorage(n, size)
}

#' Get opened page
#' 
#' Checks if there is a currently opened page. If so, returns an object with all
#' the information about the current session.
#' 
#' @return page-handling object if there is a currently opened jrc page, \code{NULL} otherwise.
#' 
#' @export
getPage <- function() {
  pkg.env$app
}

#' Set session-specific variables
#' 
#' Specifies variables that will be available (can be read or rewritten) only within a given session.
#' This is useful to safe state of the app for each client or for other personal settings. You can
#' also use it to limit user's access to data loaded in the current R session.
#' 
#' @export
setSessionVariables <- function(vars, sessionId = NULL) {
  if(is.null(pkg.env$app))
    stop("There is no opened page. Please, use 'openPage()' function to create one.")  
  
  pkg.env$app$setSessionVariables(vars, sessionId)
}

#' Get IDs of all active sessions
#' 
#' Returns IDs of all currently active sessions with date and time of their initialization
#' and the last received message.
#' 
#' @return a \code{data.frame} with three columns: \code{id} - session ID, \code{startTime} - time and date
#' of the initialization of this session, \code{lastActive} - time and date of the last received message
#' from this web socket.
#' 
#' @export
getSessionIds <- function() {
  if(is.null(pkg.env$app))
    stop("There is no opened page. Please, use 'openPage()' function to create one.")  
  
  pkg.env$app$getSessionIds()
}

#' @export
closeSession <- function(sessionId = NULL, inactive = NULL, old = NULL) {
  
}

#' @export
getMessageIds <- function(sessionId = NULL) {
  
}

#' @export
removeMessage <- function(messageId = NULL, sessionId = NULL) {
  
}